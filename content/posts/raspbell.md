---
title: "Raspbell"
author: "Julian Smolka"
summary: "A useless Raspberry Pi project."
date: 2020-05-23
type: post
draft: true
---
I moved to a new apartment a few weeks ago and noticed that I couldn't reliably hear the doorbell while listening to music. Since increasing the volume isn't possible, I thought about ways of transferring the signal generated by the doorbell to my computer and showing an alert. I don't have access to the doorbell's internal circuits so a sound sensor was the best I could do. This post is meant to be a short overview of the project.

### Setup
The main components of this project are a Raspberry Pi 4 and a digital sound sensor I found on [makershop](https://www.makershop.de/sensoren/sound/schall-sensor-modul/). The whole setup is possible because the Pi is living in the control cabinet next to the doorbell, together with the router. I also advise assigning a static local IP address to the Pi.

{{<figures>}}
  {{<figure src="posts/raspbell.jpg">}}
{{</figures>}}

Setting up the whole thing was much easier than expected. Just connect VCC, GND and OUT to the correct pins on the Pi and you are good to go. The sensor also has a potentiometer which allows fine-tuning its sensitivity. That's necessary because the sensor is digital and outputs either a high or a low signal to the GPIO pin.

### Events
The Pi includes a Python library for interacting with the GPIO. The sound sensor emits a high signal by default and switches to low when detecting a sound. As a result we have to react to a falling edge. The bounce time limits the number of fired events to one every five seconds.

```python
GPIO.setmode(GPIO.BCM)
GPIO.setup(args.pin, GPIO.IN)
GPIO.add_event_detect(args.pin, GPIO.FALLING, callback=alert, bouncetime=5000)
```

### Websockets
One hurdle to overcome was transferring the acquired data from the Pi to my computer. The easiest solution seemed to be websockets. Start a simple websocket server on the Pi since itâ€™s running all the time anyway and connect the computer once it boots. This also allows the inclusion of more devices in the future.

```python
connected = set()


async def register(websocket, path):
    connected.add(websocket)
    try:
        while websocket.open:
            await asyncio.sleep(0.1)
    except websockets.exceptions.ConnectionClosed:
        pass
    finally:
        connected.remove(websocket)
```
The server tracks all connected websockets and keeps them open until they disconnect. If an event occurs it broadcasts the data to all of them. The client itself is written in C++ instead of Python to be as efficient as possible. I am using `boost::beast` for cross-platform websockets.

### Alerts
Alerts for a rang doorbell were supposed to be as annoying as possible. Since I prefer visual cues over acoustic ones, I went with the ultimate distraction: a red fullscreen window that captures any input. I chose SDL2 as the graphics backend because I'm quite familiar with it.

```cpp
SDL_DisplayMode display;
SDL_GetCurrentDisplayMode(0, &display);

auto window = SDL_CreateWindow(
  title.c_str(),
  SDL_WINDOWPOS_UNDEFINED,
  SDL_WINDOWPOS_UNDEFINED,
  display.w, display.h,
  SDL_WINDOW_FULLSCREEN
    | SDL_WINDOW_ALWAYS_ON_TOP
    | SDL_WINDOW_INPUT_GRABBED
    | SDL_WINDOW_MOUSE_CAPTURE
);
```

### Conclusion
That's it. The Pi server is running all day and logging any activity, the client connects once the computer boots and the sound sensor is fine-tuned to the point where it should reliably pick up doorbell sounds. Let's cross fingers and hope it works in real scenarios (future me here, I stopped using it and just keep the door open).
